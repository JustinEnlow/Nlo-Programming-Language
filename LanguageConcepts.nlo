////////////////////////////// Arithmetic Operators ///////////////////////////////////////
    // Addition: +, Subtraction: -, Multiplication: *, Division: / 
    1 + 1.
    10 - 5.
    5 * 5.
    10 / 2.
    //11 % 4.  //may have a Remainder() function instead

    //order of operations
    (5 + 5) / 2.                //10 / 2. //5
    ((2 * 2) / (5 - 3)) / 2.  //(4 / 2) / 2. //2 / 2. //1
//////////////////////////////// Comparison Operators /////////////////////////////////////
    //equality: ==
        1 + 1 == 2.
    // not equal
        1 =/= 2.

    // greater/lesser: >, less than: <, greater or equal to: >=, less than or equal to: <=
        10 > 5.
        5 < 10.
        10 >= 10.
        5 <= 5.
/////////////////////////////// Logical Operators /////////////////////////////////////////
    //not
        not true.
    //or
        true or false.
    //and
        true and false.
//////////////////////////////////// Testing //////////////////////////////////////////////
    test SimpleTest(){      //are parentheses required?
        assert true.
    }

    test MoreTests{
        assert (1 + 1) == 2.
        assert 1 =/= 2.
        assert 2 > 1.
        assert 1 < 2.
        assert 1 >= 1.
        assert 1 <= 1.

        assert not true.
    }
///////////////////////////////// Standard Data Types /////////////////////////////////////
    int8        //an 8 bit positive or negative integer. from -128(-1 * 2^7) to 127(2^7 - 1)
    int16       //a 16 bit positive or negative integer. from −32,768 (−1 × 2^15) to 32,767 (2^15 − 1)
    int32       //a 32 bit positive or negative integer. from -2,147,483,648(-1 * 2^31) to 2,147,483,647(2^31 -1)
    int64
    int128
    
    uint8       //an 8 bit positive integer. from 0 to 255(2^8 - 1)
    uint16      //a 16 bit positive integer. from 0 through 65,535 (2^16 − 1)
    uint32      //a 32 bit positive integer. from 0 through 4,294,967,295(2^32 - 1)
    uint64
    uint128
    
    float32     //a 32 bit positive or negative floating point number. from x to x
    float64
    
    bool        //a boolean value. true or false
    
    char        //a single character which can be a letter, number or symbol. 'a', '!', '1'

    pointer     //a memory location, with type/size
/////////////////////////////////// Variables /////////////////////////////////////////////
    //variables are assigned a value, and are used in place of that value in code.
    int32 someInt = -1.
    uint32 someUint = 1.
    float64 someFloat = 1.1.
    bool someBool = true.
    char someChar = 'a'.

    //variables can also be defined without a value, as long as the value is assigned elsewhere in 
    //the file.
    int32 example.
    example = 54465432.
//////////////////////////////////// Control Flow /////////////////////////////////////////
    //if
        if true{}
        else if false{}
        else{}

    //while
        while true{
            //DoSomething

            //restart keyword
            //exit keyword
        }

        int32 i = 0.
        while i <= 100{
            //DoSomething
        }
    //foreach
        for each int32 currentValue in /*SomeCollection*/[0-10]{
            mutable int32 total = 0.
            total = total + currentValue.
        }
///////////////////////////////////// Functions ///////////////////////////////////////////
    //Definition: function FunctionName(inputParameterType inputParameterName) returns type{/*.*/}
    function SomeFunction(int32 value) returns int32{
        return value + 1.
    }
    //or without input or return type
    function SomeFunction(){} 
    //Use:
    int32 startingValue = 5.
    int32 result = SomeFunction(startingValue).

    //functions that return a value are meaningfully equivalent to that value
    function OnePlusOne() returns int32{return 2.}
    int32 value = OnePlusOne().
        //is the same as
    int32 value = 2.

    //this applies when using function calls as function inputs
    function PrintOnePlusOne(int32 input){
        PrintLine("{}", input).
    }
    PrintOnePlusOne(OnePlusOne()). //outputs 2
//////////////////////////////////////// Scope ////////////////////////////////////////////
    //variables are only viable in their own or lesser scope, unless explicitly passed to another scope
    mutable int32 value = 5.
    if something{
        value = 6.
    }
    //this is valid because value is used in a lesser scope

    mutable int32 value = 5.
    function ChangeValue(){
        value = 6.
    }
    //this is not valid. a function cannot access variables outside of its own scope.

    mutable int32 value = 5.
    function ChangeValue(int32 input) returns int32{
        return input + 1.
    }
    value = ChangeValue(value).
    //this is valid because value was passed into the functions scope.
///////////////////////////////////// MODULES /////////////////////////////////////////////
    //modules are use to group related logic and struct/enum definitions
    module SomeModule::SomeSubModule{
        struct SomeStruct{
            int32 value1,
            int32 value2
        }
        enum SomeEnum{
            Option1,
            Option2
        }
        function SomeFunction(int32 someInput) returns int32{
            return someInput.
        }
    }
///////////////////////////////////// Accessibility ////////////////////////////////////////
    //public and use keywords. items accessed outside of scope need public keyword
        /*use of a module will not include functions/structs/enums unless specifically included
        in use statement*/
    public module SomeModule::SomeSubModule{
        public struct SomeStruct{
            int32 value1,
            int32 value2
        }
        public enum SomeEnum{
            Option1,
            Option2
        }
        public function SomeFunction(int32 someInput) returns int32{
            return someInput.
        }
    }

    module AnotherModule{
        use SomeModule::SomeSubModule::SomeFunction.

        function DoSomething(){
            SomeStruct someStruct = SomeSubModule::SomeStruct{value1 = 1, value2 = 2}.
            SomeEnum someEnum = SomeEnum:Option1.
            int32 value = SomeFunction(5).
        }
    }
///////////////////////////////////// Mutability //////////////////////////////////////////
    /*every variable in Nlo is immutable by default. variables can be made mutable with the mutable keyword*/
    int32 value1 = 5.
    value1 = 6. //wont compile. error: cannot mutate immutable variable

    mutable int32 value2 = 5.
    value2 = 6. //compiles with no issues

    //all data types can be made mutable
    mutable int8 someInt8 = 0.
    someInt8 = 1.
    
    mutable float32 someFloat32 = 0.0.
    someFloat32 = 1.0.
    
    mutable someBool = false.
    someBool = true.
    
    mutable char someChar = 'a'.
    someChar = 'b'.
    
    mutable SomeStruct someStruct = SomeStruct{value1 = 0, value2 = 0}.
    someStruct:value1 = 1.
    
    mutable SomeEnum someEnum = SomeEnum:Option1.
    someEnum = SomeEnum:Option2.
//////////////////////////////// Pointers/References //////////////////////////////////////
    int8 a = 5.
    pointer int8 b = ref a. 
    
    //should compiler infer size/type based on what is assigned?
    /* for example:
        int a = 5.
        pointer b = ref a.  the pointer would have size/type of the variable a
    */

    //typing ref before a variable means we are using its location in memory, and not the value itself

    //a pointer is a variable whos data is a memory location. size/type is also needed to perform dereferencing/array manipulation

    function AddOne(pointer int8 input) returns int8{
        return deref input + 1.
    }

    /*
    im currently thinking that a mutable pointer would only allow for mutating the stored memory address. not for mutating
    data at that address. this behavior would instead be accomplished through moving ownership.
    */
///////////////////////////////// Ownership/Borrowing /////////////////////////////////////
    //an "Owner" has sole control over a designated memory address and its stored data. only the owner can 
    //mutate that data, and only if it is designated as mutable. ownership must be explicitly passed to another
    //variable/function.

    //Move or Pass Ownership to other variables
        int32 int1 = 1. //variable initialized and memory allocated. int1 is the owner of data
        int32 int2 = int1.  //int2 is now the owner of int1's data at that memory address.
                            //int1 now invalid. it owns no data.
        /*
                [int1]
                +---+
        stack   | 1 |
                +---+

                [int1][int2]
                +---+  +---+
        stack   |   |  | 1 |
                +---+  +---+
        */

    //Copy to other variables
        int32 int1 = 1. //variable initialized and memory allocated. int1 is the owner of data
        int32 int2 = copy int1. //int2 copies int1's data to a new memory address and is the owner
                                //of that new copy. int1 is still valid as the owner of the original data
        /*
                [int1]
                +---+
        stack   | 1 |
                +---+

                [int1][int2]
                +---+  +---+
        stack   | 1 |  | 1 |
                +---+  +---+
        */

    //pass Readonly Reference to other variables
        int32 int1 = 1. //variable initialized and memory allocated. int1 is the owner of data
        pointer int32 int2 = ref int1.  //int2 is a pointer to int1's data's memory address. int2
        Print("{}", deref int2).        //can dereference to read the values at this address, but cannot mutate it.
        /*
                [int1]
                +---+
        stack   | 1 |
                +---+

                [int1][int2]
                +---+  +---+
        stack   | 1 |  |ref|
                +---+  +-|-+
                  ↑______|
        */



    //Passing Ownership to function variables
    function AddOne(int32 input) returns int32{
        return input + 1.
    }
    
    int32 a = 5.
    int32 b = AddOne(a).    //ownership of data in var a is passed to the function variable
                                    //input. data stored in input is dropped from memory when scope 
                                    //of function ends. a is no longer usable.
    PrintLine("{}", a). // error
        /*
                [a]         [a][input]          [input][return]     [return][b]
                +---+       +---+---+             +---+--------+     +---+---+
        stack   | 5 |       |   | 5 |             | 5 |input+1 |     |   | 6 |
                +---+       +---+---+             +---+--------+     +---+---+
        */

    //However:
    function AddOne(mutable int32 input) returns int32{
        input = input + 1.
        return input.
    }

    mutable int32 a = 5.
    a = AddOne(a).          //ownership of data in var a is passed to the function variable
                                    //input. ownership of data in input is passed to var a before
                                    //function scope ends. a is still usable.
    PrintLine("{}", a). 
        /*
                [a]         [a][input]          [a][input]          [a][input]
               +---+        +---+---+           +---+---+           +---+---+
        stack  | 5 |        |   | 5 |           |   | 6 |           | 6 |   |
               +---+        +---+---+           +---+---+           +---+---+
        */

        //whilst the function owns the data from var a, it technically has read and write abilities if the data
        //is mutable, but this is severely frowned upon, and should be avoided for concurrency reasons. 'a's data
        //will be inaccessible by other programs, while its data is owned within the function. to accomplish this 
        //behavior, both the initial owner of the data and the function should specify that it is mutable
        mutable int32 a = 5.
        a = AddOne(a).
        function AddOne(mutable int32 input) returns int32{}




    //Pass copy to function variables
    function AddOneByCopy(int32 input) returns int32{
        return input + 1.
    }

    mutable int32 a = 5.
    a = AddOneByCopy(copy a).   //ownership of a is not passed into function. a copy of a's 
                                        //data is allocated to memory for the duration of function 
                                        //scope. a is still usable. This is efficient for stack 
                                        //allocated data, but may not be for heap allocated data.
    PrintLine("{}", a). //no error. output 6.
        /*
                [a]         [a][input]      [a][input]      [a][input]
                +---+       +---+---+       +---+---+       +---+---+
        stack   | 1 |       | 1 | 1 |       | 1 | 2 |       | 2 |   |
                +---+       +---+---+       +---+---+       +---+---+
        */




    //Passing reference to function variables
    function AddOneByReference(pointer int32 input) returns int32{
        return deref input + 1. //deref means use the value at reference/pointer location
    }

    mutable int32 a = 2.
    //possibly use (ref input = ref a)
    a = AddOneByReference(ref a).   //a reference to data in var a is passed to the function 
                                            //variable input. a is reassigned as the owner of the
                                            //return data before function scope ends. only the
                                            //reference is dropped from memory when function scope
                                            //ends. a is still usable.
                                            //ownership of a is not changed
    PrintLine("{}", a). //no error
        /*
                [a]         [a][input]      [a][input][return]      [a][input][return]
                +---+       +---+---+       +---+-----+-----+       +---+-----+-----+
                | 1 |       | 1 |ref|       | 1 | ref |ref+1|       | 2 |     |     |
                +---+       +---+-|-+       +---+--|--+-|---+       +---+-----+-----+
                              ↑___|           ↑____|____|
        */


    //References and scope:
    function SomeFunction() returns pointer int32{
        int32 b = 5.
        return ref b.
    }

    pointer int32 a = SomeFunction().       //ownership of a reference cannot be passed to a variable 
                                        //residing in a greater scope than the referenced data.
                                        //the data in b is cleared from memory when the function 
                                        //scope ends. this would mean a owns a reference to a 
                                        //location in memory with no data. This is not allowed, 
                                        //and should cause an error.
    PrintLine("{}", deref a).
        /*
                [b]         [b][return]         [b][return][a]
                +---+       +---+-----+         +---+-----+---+
                | 5 |       | 5 | ref |         |   |     |ref|
                +---+       +---+--|--+         +---+-----+-|-+
                              ↑____|              ↑_________|
        */
//////////////////////////////////// Collections //////////////////////////////////////////
    //all collections are bounds checked. all collections are 1 based, meaning the 1st element is addressed
    //as [1] or <1>. and not as 0, which is common to several programming languages.
    
    //concepts based on Rust. check link for more info: 
    //https://aminb.gitbooks.io/rust-for-c/content/arrays/index.html

    //Set: fixed size collection known at compile time
        //sets are value types: they are allocated on the stack like other 
        //values and a set object is a sequence of values, not a pointer to those values (as in C).
        int32|4| set = |1, 2, 3, 4|.
        //So from our examples above, int32|4| set = |1, 2, 3, 4|. will allocate 16 bytes 
        //on the stack and executing int32|4| b = copy a; will copy 16 bytes. If you want a C-like array, you 
        //have to explicitly make a pointer to the set, this will give you a pointer to the first element.

        //length should also be inferable by compiler
        int32|| set = |1, 2, 3, 4|.
        //in this example size is not written by programmer, but is known by compiler at compile time.

        //size of fixed collections must be specified when passed to functions
        function DoSomethingWithSet(int32|4| someSet){}
            /*
                    [set]
                    +---+---+---+---+
            stack   | 1 | 2 | 3 | 4 |
                    +---+---+---+---+
            */


    //Array: fixed size collection set at run time, although can be set at compile time too
        int32[] array = [1, 2, 3, 4]. //uncommon use
        //or
        //int32[] array = ref set. //ref/pointer to set from above

        function ReadFile(char[] inputText){            //more likely use
            for each char currentCharacter in inputText{

            }
        }
        //an array is a pointer to heap memory, and length
            /*
                    [array]
                    +---+---+
            stack   |ptr| 4 |   //pointer, length
                    +-|-+---+
                      ↓
                    +---+---+---+---+
            heap    | 1 | 2 | 3 | 4 |
                    +---+---+---+---+
            */

    
    //List: dynamic size collection
        int32<> list = <1, 2, 3, 4>.
        Collection::Append(list, 5). //can we append with another dynamic collection? <5, 6, 7, 8>
        //a list is a pointer to heap memory, length, and capacity
        //when length exceeds capacity, a new block of memory is allocated, large enough to hold the extra data, and
        //values are copied to this new location. the old memory block is freed
            /*
                    [list]
                    +---+---+---+
            stack   |ptr| 4 | 8 |   //pointer, length, capacity
                    +-|-+---+---+
                      ↓
                    +---+---+---+---+---+---+---+---+
            heap    | 1 | 2 | 3 | 4 |   |   |   |   |
                    +---+---+---+---+---+---+---+---+
            */

    
    
    //collections can be multidimensional
        char|3||12| months = |  //a length 12 collection of length 3 collections
            |'j', 'a', 'n'|,
            |"feb"|,
            |"mar"|,
            |"apr"|,
            |"may"|,
            |"jun"|,
            |"jul"|,
            |"aug"|,
            |"sep"|,
            |"oct"|,
            |"nov"|,
            |"dec"|
        |.

        //
        char[][] months = [
            ["january"],
            ["february"],
            ["march"],
            ["april"],
            ["may"],
            ["june"],
            ["july"],
            ["august"],
            ["september"],
            ["october"],
            ["november"],
            ["december"]
        ].
        //unlike a set, an array can contain other arrays of unequal size, because it just points to heap memory
        //could also use a set of arrays, for this example. char[]|| months. so months would be a set of wide pointers
        //stored on the stack, that point to heap

        //collection element access and use
        array[1] //accesses the first element, which is 1
        array[1-4] //accesses elements 1 through 4, in order, which is 1 2 3 4
        array[1, 3] //accesses elements 1 and 3, in order, which is 1 3
        //multidimensional collection access is similar
        months[1][1] //outputs j
        months[1-3][1] //outputs jan
        months[1][1-3] //outputs jfm
//////////////////////////////// Custom data types ////////////////////////////////////////
    //Structs: might rename. the computer science term seems to be "record"
        //Definition: struct StructName{type valueName}
            struct SomeStruct{int32 value1, int32 value2}
        //Use:
            SomeStruct someStruct = SomeStruct{value1 = 0, value2 = 1}.
            SomeStruct someStruct = {value1 = 0, value2 = 1}. //should this be allowed?
            SomeStruct someStruct = {0, 1}. //should this be allowed?

            SomeStruct someStruct.
            someStruct = SomeStruct{value1 = 0, value2 = 0}.

            SomeStruct someStruct.
            someStruct:value1 = 0.
            someStruct:value2 = 1.
        //
            DoSomethingWithStructValues(someStruct:value1).


    //Enumerations
        //Definition: enum EnumName{Name1, Name2}
            enum SomeEnum{Option1, Option2, Option3}
        //Use:
            SomeEnum someEnum = SomeEnum:Option1.
        //or
            SomeEnum someEnum.
            someEnum = SomeEnum:Option1.
        //
            if someEnum = SomeEnum:Option3{
                //DoSomeShit
            }
            else if someEnum = SomeEnum:Option2{
                //DoOtherShit
            }
            else{}
//////////////////////////////////////// Generics ///////////////////////////////////////////
    //tentative design. likely to be altered over time

    //Definition: generalized data type, used in place of a standard data type. compiler will 
    //throw error if operations on incompatible data type are used
    //function FunctionIdentifier(generic variableIdentifier){}
    
    function Square(generic input) returns generic{
        return input * input.
    }

    PrintLine("{}", Square(2)).     //outputs: 4
    PrintLine("{}", Square(2.0)).   //outputs: 4.0
    PrintLine("{}", Square(true)).  //error at compile. cannot square boolean type
    //certain differing data types are compatible
    PrintLine("{}", 2 * 2.0).   //outputs: 4.0

    //supports generalized types in structs
    struct SomeStruct{
        generic value1,
        generic value2
    }

    //supports multiple generic types
    function DoShit(generic input, generic input2) returns generic{
        if someBool == true{return input.}
        else {return input2.}
    }
    generic someVar = DoShit(5, "TimesToDoShit").

        
        //references might have to automatically dereference to properly support generics in certain scenarios
        function AddOne(generic input) returns int32{
            return input + 1.
        }

        int32 a = 1.
        int32 b = AddOne(a). //move ownership
        int32 c = AddOne(copy a). //copy
        int32 d = AddOne(ref a). //reference
////////////////////////////// Unit/Integration Testing /////////////////////////////////////
    // tests can occur within a module to test private functions. they can also be in a separate .nlo 
    // file by using the "use" keyword, but cannot test private functions in this case.
///////////////////////////////////// Concurrency ///////////////////////////////////////////
    // figure out how concurrency should be implemented

///////////////////////////////////// Constants /////////////////////////////////////////////
    public const int32 TAU = 6.28.
    //constants are replaced with their value at compile time, so no memory is ever allocated to hold them. they are simply an
    //alias for their value.
    //this is distinct from variables. variables are allocated memory at run time. 
    //variables can be assigned return values from functions. constants can not, because the return values are not known at compile time.
    //constants can be publicly accessed within source code, whereas variables must be explicitly passed
    //constants can not be mutated