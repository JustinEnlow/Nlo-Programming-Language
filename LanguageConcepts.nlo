////////////////////////////// Arithmetic Operators ///////////////////////////////////////
    // Addition: +, Subtraction: -, Multiplication: *, Division: / 
    1 + 1.
    10 - 5.
    5 * 5.   /*if possible: */ 5 ⋅ 5. /*or: */ 5 × 5.
    10 / 2.  /*if possible: */ 10 ÷ 2.
    //11 % 4.  //may have a Remainder() function instead

    //order of operations
    (5 + 5) / 2.                //10 / 2. //5
    ((2 * 2) / (5 - 3)) / 2.  //(4 / 2) / 2. //2 / 2. //1
//////////////////////////////// Comparison Operators /////////////////////////////////////
    //equality: ==
        1 + 1 == 2.
        /*ideally: */ 1 + 1 = 2.
    // not equal
        1 not= 2.
        1 /= 2.
        /*ideally: */ 1 ≠ 5.

    // greater/lesser: >, less than: <, greater or equal to: >=, less than or equal to: <=
        10 > 5.
        5 < 10.
        10 >= 10.
        /*ideally: */ 10 ≥ 10.
        5 <= 5.
        /*ideally: */ 5 ≤ 5.
/////////////////////////////// Logical Operators /////////////////////////////////////////
    //not
        not true.
    //or
        true or false.
    //and
        true and false.
//////////////////////////////////// Testing //////////////////////////////////////////////
    test SimpleTest(){      //are parentheses required?
        assert true.
    }

    test MoreTests{
        assert (1 + 1) == 2.
        assert 1 ≠ 2.
        assert 2 > 1.
        assert 1 < 2.
        assert 1 ≥ 1.
        assert 1 ≤ 1.

        assert not true.
    }
///////////////////////////////// Standard Data Types /////////////////////////////////////
    int8        //an 8 bit positive or negative integer. from -128(-1 * 2^7) to 127(2^7 - 1)
    int16       //a 16 bit positive or negative integer. from −32,768 (−1 × 2^15) to 32,767 (2^15 − 1)
    int32       //a 32 bit positive or negative integer. from -2,147,483,648(-1 * 2^31) to 2,147,483,647(2^31 -1)
    int64
    int128
    
    uint8       //an 8 bit positive integer. from 0 to 255(2^8 - 1)
    uint16      //a 16 bit positive integer. from 0 through 65,535 (2^16 − 1)
    uint32      //a 32 bit positive integer. from 0 through 4,294,967,295(2^32 - 1)
    uint64
    uint128
    
    float32     //a 32 bit positive or negative floating point number. from x to x
    float64
    
    bool        //a boolean value. true or false
    
    char        //a linguistic character. 'a', '!', '1'
/////////////////////////////////// Variables /////////////////////////////////////////////
    //variables are assigned a value, and are used in place of that value in code.
    int32 someInt = -1.
    uint32 someUint = 1.
    float64 someFloat = 1.1.
    bool someBool = true.
    char someChar = 'a'.

    //variables can also be defined without a value, as long as the value is assigned elsewhere in 
    //the file.
    int32 example.
    example = 54465432.
////////////////////////////// Expressions vs Statements //////////////////////////////////
    //expressions evaluate to a value
        x + 1 = 2. //= behaves as a comparison operator in this context
    //statements do something. assignment, function calls, etc.
        int32 y = x + 1. //= behaves as an assignment operator in this context

    bool someBool = x + 1 = 2. //= assigns as part of a statement, and compares as part of an expression
                                //when x + 1 is equivalent to 2, someBool is true
                                //otherwise it is false
                                //this is bad program design in my opinion, but should be possible
//////////////////////////////////// Control Flow /////////////////////////////////////////
    //if
        if true{}
        else if false{}
        else{}

    //while
        while true{
            //DoSomething

            //restart keyword
            //exit keyword
        }

        int32 i = 0.
        while i ≤ 100{
            //DoSomething
        }
    //foreach
        for each int32 currentValue in /*SomeCollection*/[0-10]{
            mutable int32 total = 0.
            total = total + currentValue.
        }
///////////////////////////////////// Functions ///////////////////////////////////////////
    //Definition: function FunctionName(inputParameterType inputParameterName) returns type{/*.*/}
    function SomeFunction(int32 value) returns int32{
        return value + 1.
    }
    //or without input or return type
    function SomeFunction(){} 
    //Use:
    int32 startingValue = 5.
    int32 result = SomeFunction(value = startingValue).
    int32 result = SomeFunction(startingValue). //should this be used instead? or support both?

    //functions that return a value are meaningfully equivalent to that value
    function OnePlusOne() returns int32{return 2.}
    int32 value = OnePlusOne().
        //is the same as
    int32 value = 2.

    //this applies when using function calls as function inputs
    function PrintOnePlusOne(int32 input){
        PrintLine("{}", input).
    }
    PrintOnePlusOne(input = OnePlusOne()). //outputs 2
//////////////////////////////////////// Scope ////////////////////////////////////////////
    //variable are only viable in their own or lesser scope, unless explicitly passed to another scope
    mutable int32 value = 5.
    if something{
        value = 6.
    }
    //this is valid because value is used in a lesser scope

    mutable int32 value = 5.
    function ChangeValue(){
        value = 6.
    }
    //this is not valid. a function cannot access variables outside of its own scope.

    mutable int32 value = 5.
    function ChangeValue(int32 input) returns int32{
        return input + 1.
    }
    value = ChangeValue(input = value).
    //this is valid because value was passed into the functions scope.
///////////////////////////////////// MODULES /////////////////////////////////////////////
    //modules are use to group related logic and struct/enum definitions
    module SomeModule::SomeSubModule{
        struct SomeStruct{
            int32 value1,
            int32 value2
        }
        enum SomeEnum{
            Option1,
            Option2
        }
        function SomeFunction(int32 someInput) returns int32{
            return someInput.
        }
    }
///////////////////////////////////// Accessibility ////////////////////////////////////////
    //public and use keywords. items accessed outside of scope need public keyword
        /*use of a module will not include functions/structs/enums unless specifically included
        in use statement*/
    public module SomeModule::SomeSubModule{
        public struct SomeStruct{
            int32 value1,
            int32 value2
        }
        public enum SomeEnum{
            Option1,
            Option2
        }
        public function SomeFunction(int32 someInput) returns int32{
            return someInput.
        }
    }

    module AnotherModule{
        use SomeModule::SomeSubModule::SomeFunction.

        function DoSomething(){
            SomeStruct someStruct = SomeSubModule::SomeStruct{value1 = 1, value2 = 2}.
            SomeEnum someEnum = SomeEnum:Option1.
            int32 value = SomeFunction(5).
        }
    }
///////////////////////////////////// Mutability //////////////////////////////////////////
    /*every variable in Nlo is immutable by default. variables can be made mutable with the mutable keyword*/
    int32 value1 = 5.
    value1 = 6. //wont compile. error: cannot mutate immutable variable

    mutable int32 value2 = 5.
    value2 = 6. //compiles with no issues

    //all data types can be made mutable
    mutable int8 someInt8 = 0.
    someInt8 = 1.
    
    mutable float32 someFloat32 = 0.0.
    someFloat32 = 1.0.
    
    mutable someBool = false.
    someBool = true.
    
    mutable char someChar = 'a'.
    someChar = 'b'.
    
    mutable SomeStruct someStruct = SomeStruct{value1 = 0, value2 = 0}.
    someStruct:value1 = 1.
    
    mutable SomeEnum someEnum = SomeEnum:Option1.
    someEnum = SomeEnum:Option2.
///////////////////////////////// Ownership/Borrowing /////////////////////////////////////
    //Passing Ownership:
    function AddOne(int32 input) returns int32{
        return input + 1.
    }
    
    int32 a = 5.
    int32 b = AddOne(input = a).    //ownership of data in var a is passed to the function variable
                                    //input. data stored in input is dropped from memory when scope 
                                    //of function ends. a is no longer usable.
    PrintLine("{}", a). // error
    //However:
    mutable int32 a = 5.
    a = AddOne(input = a).          //ownership of data in var a is passed to the function variable
                                    //input. ownership of data in input is passed to var a before
                                    //function scope ends. a is still usable.
    PrintLine("{}", a). 

    //Passing reference:
    function AddOneByReference(ref int32 input) returns int32{
        return deref input + 1. //deref means use the value at reference/pointer location
    }

    mutable int32 a = 2.
    //possibly use (ref input = ref a)
    a = AddOneByReference(input = ref a).   //a reference to data in var a is passed to the function 
                                            //variable input. a is reassigned as the owner of the
                                            //return data before function scope ends. only the
                                            //reference is dropped from memory when function scope
                                            //ends. a is still usable.
                                            //ownership of a is not changed
    PrintLine("{}", a). //no error

    //Pass a copy of data: another potential. not decided
    function AddOneByCopy(copy int32 input) returns int32{
        return input + 1.
    }

    mutable int32 a = 5.
    a = AddOneByCopy(input = copy a).   //ownership of a is not passed into function. a copy of a's 
                                        //data is allocated to memory for the duration of function 
                                        //scope. a is still usable. This is efficient for stack 
                                        //allocated variables, but not heap allocated variables.
    PrintLine("{}", a). //no error. output 6.

    //References and scope:
    function SomeFunction() returns ref int32{
        int32 b = 5.
        return ref b.
    }

    ref int32 a = SomeFunction().       //ownership of a reference cannot be passed to a variable 
                                        //residing in a greater scope than the referenced data.
                                        //the data in b is cleared from memory when the function 
                                        //scope ends. this would mean a owns a reference to a 
                                        //location in memory with no data. This is not allowed, 
                                        //and should cause an error.
    PrintLine("{}", deref a).
//////////////////////////////////// Collections //////////////////////////////////////////
    //all collections are bounds checked. all collections are 1 based, meaning the 1st element is addressed
    //as [1] or <1>. and not as 0, which is common to several programming languages.
    
    //concepts based on Rust. check link for more info: 
    //https://aminb.gitbooks.io/rust-for-c/content/arrays/index.html

    //fixed collection of known size at compile time
        //known size collections are value types: they are allocated on the stack like other 
        //values and an array object is a sequence of values, not a pointer to those values (as in C).
        int32[4] sizedFixedCollection = [1, 2, 3, 4].    //might allow "= 1, 2, 3, 4." , in future
        //So from our examples above, int32[4] sizedFixedCollection = [1, 2, 3, 4]. will allocate 16 bytes 
        //on the stack and executing int32[4] b = a; will copy 16 bytes. If you want a C-like array, you 
        //have to explicitly make a pointer to the array, this will give you a pointer to the first element.

        //length should also be inferable by compiler
        int32[] sizedFixedCollection = [1, 2, 3, 4].
        //size is not written by programmer, but is known by compiler at compile time.

        //size of fixed collections must be specified when passed to functions
        function DoSomethingWithFixedCollection(int32[4] collection){

        }

        //collections can be multidimensional
        char[3][12] months = [  //a length 12 collection of length 3 collections
            ['j', 'a', 'n'],
            ["feb"],
            ["mar"],
            ["apr"],
            ["may"],
            ["jun"],
            ["jul"],
            ["aug"],
            ["sep"],
            ["oct"],
            ["nov"],
            ["dec"]
        ].

        //collection element access and use
        sizedFixedCollection[1] //accesses the first element, which is 1
        sizedFixedCollection[1-4] //accesses elements 1 through 4, in order, which is 1 2 3 4
        sizedFixedCollection[1, 3] //accesses elements 1 and 3, in order, which is 1 3
        //multidimensional array access is similar
        months[1][1] //outputs j
        months[1-3][1] //outputs jan
        months[1][1-3] //outputs jfm

    //fixed collection of unknown size at compile/run time
        ref int32[] unsizedFixedCollection = ref [1, 2, 3, 4]. //uncommon use
        //or
        ref int32[] unsizedFixedCollection = ref sizedFixedCollection. //ref/pointer to sizedFixedCollection from above

        function ReadFile(ref char[] inputText){            //more likely use
            for each char currentCharacter in inputText{

            }
        }

        ref ref int32[][] collection. //this could get wild...
    
    //dynamic collection 
        int32<> dynamicallySizedCollection = <1, 2, 3, 4>.
        Collection::Append(dynamicallySizedCollection, 5). //can we append with another dynamic collection? <5, 6, 7, 8>
//////////////////////////////// Custom data types ////////////////////////////////////////
    //Structs
        //Definition: struct StructName{type valueName}
            struct SomeStruct{int32 value1, int32 value2}
        //Use:
            SomeStruct someStruct = SomeStruct{value1 = 0, value2 = 1}.
            SomeStruct someStruct = {value1 = 0, value2 = 1}. //should this be allowed?
            SomeStruct someStruct = {0, 1}. //should this be allowed?

            SomeStruct someStruct.
            someStruct = SomeStruct{value1 = 0, value2 = 0}.

            SomeStruct someStruct.
            someStruct:value1 = 0.
            someStruct:value2 = 1.
        //
            DoSomethingWithStructValues(param1 = someStruct:value1).


    //Enumerations
        //Definition: enum EnumName{Name1, Name2}
            enum SomeEnum{Option1, Option2, Option3}
        //Use:
            SomeEnum someEnum = SomeEnum:Option1.
        //or
            SomeEnum someEnum.
            someEnum = SomeEnum:Option1.
        //
            if someEnum = SomeEnum:Option3{
                //DoSomeShit
            }
            else if someEnum = SomeEnum:Option2{
                //DoOtherShit
            }
            else{}
//////////////////////////////////////// Generics ///////////////////////////////////////////
    //tentative design. likely to be altered over time

    //Definition: generalized data type, used in place of a standard data type. compiler will 
    //throw error if operations on incompatible data type are used
    //function FunctionIdentifier(generic variableIdentifier){}
    
    function Square(generic input) returns generic{
        return input * input.
    }

    PrintLine("{}", Square(input = 2)).     //outputs: 4
    PrintLine("{}", Square(input = 2.0)).   //outputs: 4.0
    PrintLine("{}", Square(input = true)).  //error at compile. cannot square boolean type
    //certain differing data types are compatible
    PrintLine("{}", 2 * 2.0).   //outputs: 4.0

    //supports generalized types in structs
    struct SomeStruct{
        generic value1,
        generic value2
    }

    //supports multiple generic types
    function DoShit(generic input, generic input2) returns generic{
        if someBool == true{return input.}
        else {return input2.}
    }
    generic someVar = DoShit(input = 5, input2 = "TimesToDoShit").
////////////////////////////// Unit/Integration Testing /////////////////////////////////////
    // tests can occur within a module to test private functions. they can also be in a separate .nlo 
    // file by using the "use" keyword, but cannot test private functions in this case.
///////////////////////////////////// Concurrency ///////////////////////////////////////////
